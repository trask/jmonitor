/*
 * Copyright 2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jmonitor.agent;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;

import org.jmonitor.agent.impl.Agent;
import org.jmonitor.agent.impl.model.OperationSafeImpl;
import org.jmonitor.agent.impl.model.TraceEventSafeImpl;
import org.jmonitor.api.probe.ProbeExecution;
import org.jmonitor.extension.probe.JdbcProbeExecution;
import org.jmonitor.mock.MockProbeExecution;
import org.jmonitor.mock.WrapInMockProbeExecution;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.jdbc.core.CallableStatementCreator;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterators;

/**
 * Basic tests of JdbcAspect.
 * 
 * @author Trask Stalnaker
 * @since 1.0
 */
@ContextConfiguration(locations = "/applicationContext-test.xml")
public class JdbcProbeTest extends AbstractTransactionalJUnit4SpringContextTests {

    // when running with load time weaving against all classes (no filter in aop.xml),
    // the monitor catches some internal sql queries generated by the hsqldb driver
    // e.g. org.springframework.jdbc..StatementCreatorUtils.setNull()
    // -> DatabaseMetaData.getDatabaseProductName()
    // which hsqldb driver handles by executing a sql call
    // {call "org.hsqldb.Library.getDatabaseProductName"()}
    // against the database
    // these are OK as far as the monitor is concerned (they are just tracked as any
    // other database query, but they mess up the tests, so this is a filter to make
    // the tests invariant of these internal calls
    private static final Predicate<TraceEventSafeImpl> EXECUTION_TRACE_ELEMENT_FILTER =
            new Predicate<TraceEventSafeImpl>() {
                public boolean apply(TraceEventSafeImpl input) {
                    if (input.getProbeExecution() instanceof JdbcProbeExecution) {
                        JdbcProbeExecution jdbcTracElement =
                                (JdbcProbeExecution) input.getProbeExecution();
                        return jdbcTracElement.getSql() != null
                                && !jdbcTracElement.getSql().contains(
                                        "org.hsqldb.Library.getDatabaseProductName");
                    } else {
                        return true;
                    }
                }
            };

    @Before
    public void setUp() {

        simpleJdbcTemplate.getJdbcOperations().execute("create table employee (name varchar(100))");
        simpleJdbcTemplate.getJdbcOperations().execute(
                "insert into employee (name) values ('john doe')");
    }

    @After
    public void tearDown() {

        // clean up database
        simpleJdbcTemplate.getJdbcOperations().execute("drop table employee");
    }

    @Test
    @WrapInMockProbeExecution
    public void testStatement() {

        String sql = "select * from employee";

        simpleJdbcTemplate.queryForList(sql);

        // perform assertions
        Iterator<JdbcProbeExecution> iterator = getJdbcProbeExecutions();
        assertTrue(iterator.hasNext());
        JdbcProbeExecution jdbcProbeExecution = iterator.next();
        assertSame(sql, jdbcProbeExecution.getSql());
        assertNull(jdbcProbeExecution.getParameters());
        assertEquals(1, jdbcProbeExecution.getNumRows());
    }

    @Test
    @WrapInMockProbeExecution
    public void testPreparedStatement() {

        String sql = "select * from employee where name like ?";
        String param = "john%";

        simpleJdbcTemplate.queryForList(sql, param);

        // perform assertions
        Iterator<JdbcProbeExecution> iterator = getJdbcProbeExecutions();
        assertTrue(iterator.hasNext());
        JdbcProbeExecution jdbcProbeExecution = iterator.next();
        assertSame(jdbcProbeExecution.getSql(), sql);
        assertEquals(1, jdbcProbeExecution.getParameters().size());
        assertEquals(param, jdbcProbeExecution.getParameters().get(0));
        assertEquals(1, jdbcProbeExecution.getNumRows());
    }

    @Test
    @WrapInMockProbeExecution
    public void testPreparedStatementWithSetNull() {

        String sql = "insert into employee (name) values (?)";

        simpleJdbcTemplate.update(sql, (Object) null);

        // perform assertions
        Iterator<JdbcProbeExecution> iterator = getJdbcProbeExecutions();
        assertTrue(iterator.hasNext());
        JdbcProbeExecution jdbcProbeExecution = iterator.next();
        assertSame(sql, jdbcProbeExecution.getSql());
        assertEquals(1, jdbcProbeExecution.getParameters().size());

        // Spring JDBC uses setObject(0, null) instead of setNull() for Microsoft SQLServer and
        // Informix, see org.springframework.jdbc.core.StatementCreatorUtils.setNull()
        if (jdbcProbeExecution.getParameters().get(0) != null
                && !jdbcProbeExecution.getParameters().get(0).equals(
                        JdbcProbeExecution.NULL_PARAMETER)) {

            fail();
        }
    }

    @Test
    @WrapInMockProbeExecution
    public void testCallableStatement() {

        String sql = "select * from employee where name = ?";
        String param = "john%";

        simpleJdbcTemplate.getJdbcOperations().call(new SimpleCallableStatementCreator(sql, param),
                new ArrayList<SqlParameter>());

        // perform assertions
        Iterator<JdbcProbeExecution> iterator = getJdbcProbeExecutions();
        assertTrue(iterator.hasNext());
        JdbcProbeExecution jdbcProbeExecution = iterator.next();
        assertSame(jdbcProbeExecution.getSql(), sql);
        assertEquals(1, jdbcProbeExecution.getParameters().size());
        assertEquals(param, jdbcProbeExecution.getParameters().get(0));
        assertEquals(0, jdbcProbeExecution.getNumRows());
    }

    // TODO make a release build profile that runs all tests against Hsqldb, Oracle, SQLServer,
    // MySQL, ...
    @Test
    @WrapInMockProbeExecution
    public void testSqlServerIssueStatement() {

        // exploits issue with SQLServer PreparedStatement.getParameterMetaData(), result being that
        // we cannot use getParameterMetaData() in JdbcProbe, this test (if we can figure out a run
        // against SQLServer)
        // ensures that getParameterMetaData() doesn't sneak back in the future
        String sql = "select * from employee where (name like ?)";
        String param = "john%";

        simpleJdbcTemplate.queryForList(sql, param);

        // perform assertions
        Iterator<JdbcProbeExecution> iterator = getJdbcProbeExecutions();
        assertTrue(iterator.hasNext());
        JdbcProbeExecution jdbcProbeExecution = iterator.next();
        assertSame(jdbcProbeExecution.getSql(), sql);
        assertEquals(1, jdbcProbeExecution.getParameters().size());
        assertEquals(param, jdbcProbeExecution.getParameters().get(0));
        assertEquals(1, jdbcProbeExecution.getNumRows());
    }

    private Iterator<JdbcProbeExecution> getJdbcProbeExecutions() {

        OperationSafeImpl operation = Agent.getInstance().getCurrentOperation();

        Iterator<TraceEventSafeImpl> iterator =
                operation.getTrace().getEvents().iterator();

        // strip off MockProbeExecution element
        assertTrue(iterator.hasNext());
        ProbeExecution mockProbeExecution = iterator.next().getProbeExecution();
        assertNotNull(mockProbeExecution);
        assertTrue(mockProbeExecution instanceof MockProbeExecution);

        // filter out internal hsqldb jdbc queries
        iterator = Iterators.filter(iterator, EXECUTION_TRACE_ELEMENT_FILTER);

        // convert to ProbeExecution iterator
        return Iterators.transform(iterator,
                new Function<TraceEventSafeImpl, JdbcProbeExecution>() {
                    public JdbcProbeExecution apply(TraceEventSafeImpl from) {
                        return (JdbcProbeExecution) from.getProbeExecution();
                    }
                });
    }

    private static class SimpleCallableStatementCreator implements CallableStatementCreator {

        private final String sql;
        private final String param;

        public SimpleCallableStatementCreator(String sql, String param) {
            this.sql = sql;
            this.param = param;
        }

        public CallableStatement createCallableStatement(Connection connection) throws SQLException {
            CallableStatement callableStatement = connection.prepareCall(sql);
            callableStatement.setString(1, param);
            return callableStatement;
        }
    }
}
