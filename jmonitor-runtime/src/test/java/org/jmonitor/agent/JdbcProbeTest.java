/**
 * Copyright 2010 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jmonitor.agent;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;

import org.jmonitor.agent.impl.Agent;
import org.jmonitor.agent.impl.model.ExecutionTraceElementSafeImpl;
import org.jmonitor.agent.impl.model.OperationSafeImpl;
import org.jmonitor.api.probe.ProbeExecution;
import org.jmonitor.extension.probe.JdbcProbeExecution;
import org.jmonitor.mock.MockProbeExecution;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.jdbc.core.CallableStatementCreator;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests;

import com.google.common.base.Predicate;
import com.google.common.collect.Iterators;

/**
 * Basic tests of JdbcAspect.
 * 
 * @author Trask Stalnaker
 * @since 1.0
 */
@ContextConfiguration(locations = "/applicationContext-test.xml")
public class JdbcProbeTest extends AbstractTransactionalJUnit4SpringContextTests {

    private ExecutionTraceElementSafeImpl rootTraceElement;

    // when running with load time weaving against all classes (no filter in aop.xml),
    // the monitor catches some internal sql queries generated by the hsqldb driver
    // e.g. org.springframework.jdbc..StatementCreatorUtils.setNull()
    // -> DatabaseMetaData.getDatabaseProductName()
    // which hsqldb driver handles by executing a sql call
    // {call "org.hsqldb.Library.getDatabaseProductName"()}
    // against the database
    // these are OK as far as the monitor is concerned (they are just tracked as any
    // other database query, but they mess up the tests, so this is a filter to make
    // the tests invariant of these internal calls
    private static final Predicate<ExecutionTraceElementSafeImpl> hsqldbQueryTraceElementFilter =
            new Predicate<ExecutionTraceElementSafeImpl>() {
                public boolean apply(ExecutionTraceElementSafeImpl input) {
                    if (input.getProbeExecution() instanceof JdbcProbeExecution) {
                        JdbcProbeExecution jdbcTracElement = (JdbcProbeExecution) input
                                .getProbeExecution();
                        return jdbcTracElement.getSql() != null
                                && !jdbcTracElement.getSql().contains(
                                        "org.hsqldb.Library.getDatabaseProductName");
                    } else {
                        return true;
                    }
                }
            };

    @Before
    public void setUp() {

        simpleJdbcTemplate.getJdbcOperations().execute("create table employee (name varchar(100))");
        simpleJdbcTemplate.getJdbcOperations().execute(
                "insert into employee (name) values ('john doe')");

        // start mockProbeExecution to capture child trace elements
        rootTraceElement = Agent.getInstance().pushTraceElement(new MockProbeExecution());
    }

    @After
    public void tearDown() {

        // end mockProbeExecution
        Agent.getInstance().popTraceElement(rootTraceElement);

        // clean up database
        simpleJdbcTemplate.getJdbcOperations().execute("drop table employee");
    }

    @Test
    public void testStatement() {

        String sql = "select * from employee";

        simpleJdbcTemplate.queryForList(sql);

        // perform assertions
        OperationSafeImpl operation = Agent.getInstance().getCurrentOperation();
        Iterator<ExecutionTraceElementSafeImpl> iterator = operation.getExecutionTrace()
                .getElements().iterator();
        assertTrue(iterator.hasNext());
        ProbeExecution mockProbeExecution = iterator.next().getProbeExecution();
        assertNotNull(mockProbeExecution);
        assertTrue(mockProbeExecution instanceof MockProbeExecution);
        assertTrue(iterator.hasNext());
        ProbeExecution probeExecution = iterator.next().getProbeExecution();
        assertTrue(probeExecution instanceof JdbcProbeExecution);
        JdbcProbeExecution jdbcProbeExecution = (JdbcProbeExecution) probeExecution;
        assertSame(sql, jdbcProbeExecution.getSql());
        assertNull(jdbcProbeExecution.getParameters());
        assertEquals(1, jdbcProbeExecution.getNumRows());
    }

    @Test
    public void testPreparedStatement() {

        String sql = "select * from employee where name like ?";
        String param = "john%";

        simpleJdbcTemplate.queryForList(sql, param);

        // perform assertions
        OperationSafeImpl operation = Agent.getInstance().getCurrentOperation();
        Iterator<ExecutionTraceElementSafeImpl> iterator = operation.getExecutionTrace()
                .getElements().iterator();
        assertTrue(iterator.hasNext());
        ProbeExecution mockProbeExecution = iterator.next().getProbeExecution();
        assertNotNull(mockProbeExecution);
        assertTrue(mockProbeExecution instanceof MockProbeExecution);
        assertTrue(iterator.hasNext());
        ProbeExecution probeExecution = iterator.next().getProbeExecution();
        assertTrue(probeExecution instanceof JdbcProbeExecution);
        JdbcProbeExecution jdbcProbeExecution = (JdbcProbeExecution) probeExecution;
        assertSame(jdbcProbeExecution.getSql(), sql);
        assertEquals(1, jdbcProbeExecution.getParameters().size());
        assertEquals(param, jdbcProbeExecution.getParameters().get(0));
        assertEquals(1, jdbcProbeExecution.getNumRows());
    }

    @Test
    public void testPreparedStatementWithSetNull() {

        String sql = "insert into employee (name) values (?)";

        simpleJdbcTemplate.update(sql, (Object) null);

        // perform assertions
        OperationSafeImpl operation = Agent.getInstance().getCurrentOperation();
        Iterator<ExecutionTraceElementSafeImpl> iterator = operation.getExecutionTrace()
                .getElements().iterator();
        iterator = Iterators.filter(iterator, hsqldbQueryTraceElementFilter);
        assertTrue(iterator.hasNext());
        ProbeExecution mockProbeExecution = iterator.next().getProbeExecution();
        assertNotNull(mockProbeExecution);
        assertTrue(mockProbeExecution instanceof MockProbeExecution);
        assertTrue(iterator.hasNext());
        ProbeExecution probeExecution = iterator.next().getProbeExecution();
        assertTrue(probeExecution instanceof JdbcProbeExecution);
        JdbcProbeExecution jdbcProbeExecution = (JdbcProbeExecution) probeExecution;
        assertSame(sql, jdbcProbeExecution.getSql());
        assertEquals(1, jdbcProbeExecution.getParameters().size());
        assertEquals(JdbcProbeExecution.NULL_PARAMETER, jdbcProbeExecution.getParameters().get(0));
    }

    @Test
    public void testCallableStatement() {

        String sql = "select * from employee where name = ?";
        String param = "john%";

        simpleJdbcTemplate.getJdbcOperations().call(new SimpleCallableStatementCreator(sql, param),
                new ArrayList<SqlParameter>());

        // perform assertions
        OperationSafeImpl operation = Agent.getInstance().getCurrentOperation();
        Iterator<ExecutionTraceElementSafeImpl> iterator = operation.getExecutionTrace()
                .getElements().iterator();
        assertTrue(iterator.hasNext());
        ProbeExecution mockProbeExecution = iterator.next().getProbeExecution();
        assertNotNull(mockProbeExecution);
        assertTrue(mockProbeExecution instanceof MockProbeExecution);
        assertTrue(iterator.hasNext());
        ProbeExecution probeExecution = iterator.next().getProbeExecution();
        assertTrue(probeExecution instanceof JdbcProbeExecution);
        JdbcProbeExecution jdbcProbeExecution = (JdbcProbeExecution) probeExecution;
        assertSame(jdbcProbeExecution.getSql(), sql);
        assertEquals(1, jdbcProbeExecution.getParameters().size());
        assertEquals(param, jdbcProbeExecution.getParameters().get(0));
        assertEquals(0, jdbcProbeExecution.getNumRows());
    }

    private static class SimpleCallableStatementCreator implements CallableStatementCreator {

        private final String sql;
        private final String param;

        public SimpleCallableStatementCreator(String sql, String param) {
            this.sql = sql;
            this.param = param;
        }

        public CallableStatement createCallableStatement(Connection connection) 
                throws SQLException {
            
            CallableStatement callableStatement = connection.prepareCall(sql);
            callableStatement.setString(1, param);
            return callableStatement;
        }
    }
}
